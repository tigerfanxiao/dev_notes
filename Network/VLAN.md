### VLAN 默认ID
在思科设备上
VLAN 1 是默认的， 也称为本征VLAN， 不打TAG， 不能删除
VLANs 1002-1005 是老协议用的。 


VLAN 可以认为是一种虚拟化技术. 通过 vlan 我们可以把一个交换机分为多个交换机.
每个交互机之间在二层网络中内隔绝开. 

比如我们把交换机的接口 1-10 分给 vlan1, 把接口 11-20 分给 vlan2. 你可以认为一个 vlan 就是一台虚拟的交换机. 那么在这种情况下, vlan1 和 vlan2 是无法完成二层通信的. 他们不会收到对方的广播报文. 

怎么实现vlan1 和 vlan2 的分割呢? 我们使用打 tag 的方法. 

### VLAN tag

| dmac | smac | 802.1Q_tag |  类型 |  Data | FCS  |
* 802.1Q_TAG 有
	* TPID = 0x8100 表示802.1Q
	* PRI 优先级, 主要用于 QoS
	* CFI 以太网中为 0
	* VLAN ID  12bit, 有 2^12 = 4096 个

交换机只会把这个帧从加入了 vlan1 的那些接口发出去, 而不会从加入了 vlan2 的那些发出去. 同时, 因为 tag 只是在交换机内使用, 所以在发出去的时候, 还得把这个 tag 给剥离了. 这种打 tag 的方式也称为 dot1Q

上面提到的是一种非常简化的环境, 非常小型的网络. 一台交换机就把所有的设备连接起来了. 
但是现实的情况更复杂. 我们考虑一种情况. 我们有幢楼, 每幢楼各有一台交换机. 然后我们有两个部门: 部门 1 和部门 2. 他们在两幢楼都有办公人员. 我们允许他们部门内部的通信, 但是不允许部门间相互通信, 要怎么实现? 这个时候我们就要引入 Trunk 了


# Trunk
要让两幢楼的人相互通信, 我们就要将两台交换机连接起来. 但是要隔开两个部门的人, 我们就要用 vlan 打 tag 的方式, 把接口划分到各自的 vlan下. 同时, 因为对面楼也有自己部门的人, 我们就要把数据通过两个交换机的连线发送出去. 这种情况下, 我们就需要一种新的接口, 称为 trunk 口. 这种 trunk 口的连线可以同时允许 vlan1 和 vlan2 的数据通过. 等数据传到了对面的交换机之后, 再根据帧中的 tag 信息来决定去往那个对应 vlan. 基于这种想法, 因为 tag 信息在到达对面交换机时是必要的, 数据在离开本地交换机 trunk 口的时候, 就不做剥离 tag 的动作了. 
对应的, 我们把之前那种需要做剥离动作的接口称为 Access 接口. 

可以简单的总结, Access 接口一般接的是终端设备, 而 trunk 接口一般接的交换机. 
在现在的虚拟化服务器, 可以连接 Trunk. 因为一个物理服务器上有很多虚拟服务器, 对虚拟服务器划分在多个 vlan 中, 所以他们的流量在出去的时候, 是经过 trunk 口.

服务器的网卡支持改 VLAN 
在华为设备上通过接口下的 vlan list 来确定放行哪些 vlan
在华为设备上 PVID 用来控制加 tag 和剥离 tag.

### Trunk 中 PVID 的作用
如果网络中的某个 vlan 流量特别大, 明显大于其他 vlan, 那么把这个 PVID 设置为这个 VLAN, 从此这个流量在 trunk 上传输就没有标签. 这样就提高了转发速率
具体来说, 我收到不带标签的数据, 我把它标记为vlan20. 当我收到vlan20的数据, 从我的接口出去的时候, 不打标签


### VLAN 划分方式
* 基于接口 问题是不灵活, 如果主机连接了其他接口, 就需要重新划分. PVID
* 基于 MAC 地址 可以规避主机更换端口的问题, 但是每个交换机都要配置 mac-vlan 映射表
* 基于 IP 子网划分
* 基于协议划分 IPv4, IPv6 在运营商中使用
* 基于策略 10.0.1.* + GE0/0/1 + MAC1

> 华为的交换机, 每个接口都有 PVID 为 1. 即所有端口都在 VLAN 1 中. 


### 华为交换机接口类型
1. Access 接口
2. Trunk 接口
3. hybrid 接口 收到行为和 trunk 一样, 发的时候可以由管理员决定 tag 的去留
这种华为交换机的默认端口, 既能做 access 接口, 也能做 trunk 口, 可以对 tag 做灵活的控制

# QinQ
从技术上理解, 就是在原来的 vlan tag 之外, 再加了一层 tag. 作用是为了区分不同的 ISP 厂商. 
想象一下, 在城域网中, 有很多不同ISP, 可能有些是虚拟的. 私网的 vlan 流量在传输到 ISP 的 MPLS 域时, 内部有一个 vlan 标签, 代表私网的 vlan, 外部再包一层 vlan 标签, 代表不同的 ISP. 这样在城域网的不同 AS 之间传输时, 就知道该给对端 AS 的那个 vlan 了. 


# 三层交换机
## vlanif
vlanif接口和子接口功能类似， 但不是相同的东西
vlanif 10 是三层交换机上的， 必然对应vlan 10。 是在三层交换机上的路由模块， 终结vlan10。 子接口是对应路由器上的
但是 int g0/0/0.10 只是一个子接口的编号。 对应的vlan需要看子接口下dot1q的配置
vlanif使用的mac地址同为交换机的mac地址

所以三层交换机有三张表
1. 路由表 - 三层 vlanif 之间的路由
2. ARP表 - 三层
3. MAC地址表 - 二层 处理二层转发


vlanif up的条件
1. 物理接口已经划分到对应的vlan
2. vlanif下已经配置了ip地址

### 命令

```shell
# 查看所有vlan
display vlan 
# 批量创建vlan
vlan batch 10 20 30

# 查看mac地址表
display mac-address
```

access口相关命令

```shell
# acces 口划分 vlan
int g0/0/3
port link-type access # 修改为 access 接口
port default vlan 20 #  收到包后打上 tag 20, 发出的时候剥离20

# 将access口改为trunk
int g0/0/0
undo port default vlan # 注意这里不要加vlan 编号， undo port default vlan 10会报错
port link-type trunk 
```

```shell
SW1
int vlanif 10
ip add 192.168.10.254

int vlanif 20
ip add 192.168.20.254
```

### 删除 vlan 的方法
```
undo port default vlan 20
undo port link-type 
```

错误案例

![[Pasted image 20230825203402.png]]
PC1(左边)要访问 PC2. 首先判断 PC2 的 IP 地址和自己是不是在一个网段中. 如果在, 则使用广播来请求 192.168.1.2 的 MAC 地址. 但是因为 192.168.1.2 在 vlan20 中, 和 vlan10 不是同一个广播域, 所以收不到广播. 
如果把 PC2 的 IP 地址改为 192.168.2.1, 此时 PC1 发现目标地址和自己不在一个网段中, 就会把包发给网关. 如果在网关上有对应路由, 则会经过网关走三成转发. 

### 给交换机接口转化为三层

```shell
# 先创建vlan
vlan batch 12
int vlan 12 # 创建 vlanif
ip add 192.168.12.1 24

```