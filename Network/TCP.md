[视频参考](https://www.youtube.com/watch?v=Iuvjwrm_O5g)[[OSI 模型]]
TCP 是为了在不可靠的信道上建立起可靠的连接. 所以使用三次握手. 
为什么说网络层是不可靠的信道? 因为在 IP 报头中只多 IP header 进行了差错校验. 并没有对内容进行校验. 网络层主要做的对丢包的校验. 比如 ECN 字段显示在非丢包情况下的网络拥塞情况. 
TCP 可以分为3 个阶段, 建立连接, 传输数据, 断开连接. 

TCP 为什么要用三次握手而不是两次握手?
假设A 向 B 发送了一个 SYN1 请求, 因为信道不可靠, 没有送到 B. 过了一段时间因为 A 没有收到 B 的回复, A 又发送了 SYN2请求, 这次 B 收到了, 且回复了. 这种时候, 我们认为由 SYN2 发起的连接已经在双方建立成功了. 就在这个时候, SYN1的信道恢复了, 也到达了 B, B 认为这是一个新的连接请求, 于是回复给 A, 但是 A 只需要一个连接. 而 B 这个时候却认为自己有 2 个连接. 因为通信已经结束, A 也不会再发送请求告诉 B, 其实它只需要一个连接. 

### TCP 三次握手过程
三次握手没有传实际的数据, 只是建立连接. 数据是在三次握手完成后开始传输的
1. A 初始为init 状态. A向 B 发送 SYN 包, 自己进入 SYN-Send 状态, B 初始为 Listen 状态
	 序列号是随机的 a, 确认号为 0.  Flags: SYN 置位
2. B 收到 A 发来的 SYN 包之后,进入 SYN-RCVD 状态, 发送 SYN + ACK 包, 
	序列号是随机的 b, 确认号是 a + 1. Flags: SYN 置位 , ACK置位
3. A 收到 B 发来的 SYN + ACK包之后, 发送 ACK 包, 进入 Established 状态
	序列号是 a + 1, 确认号是 b + 1. Flags : ACK 置位
4. B 收到A发来的 ACK 包之后, 进入 Established 状态
三次握手之后, 开始传递数据. 序列号a+1和 ack=b+1 号都用的是第三次握手的结果. 但是在 flags 里 syn=0 ack=1 不是建立连接用的. 如果应用层数据报文长度 127 Byte. 服务器回包seq = b+1, ack=a+1+127
说明服务器正确收到了上一个报文

* ack = 上一个报文的 seq + 应用层字节数(实际负载)
* seq = 上一个报文的 ack

上面这个过程称为 TCP 的逐包确认. 但是在实际上, 我们会一次发多个 TCP 报文, 回包也把多个包的序列号加起来作为 ack

flag 位 syn 表示期望和对端建立连接, 在连接建立后, 就不用了. 只用 ack 位

TCP 传输数据
TCP 连接时全双工的. 在数据传输的过程中, 不区分客户端和服务端
当连接建立完成后, 进入数据传输阶段. 此时就要考虑几个问题
1. 传输过程中的丢包问题. 
	建立发送缓冲区, 将数据分成包, 排好序, 可以多个一起发送. 接受方收到后,返回ACK, 里面是下一个报文的起始位置和偏移量. 如果发现包丢失, 就把缺失的包的起始序列号发给发送方
2. 包之间的顺序问题
	发送的报头中, 有包的顺序

TCP 四次挥手过程
关闭连接可以是双向的. 现在假设是客户端向服务请求关闭连接
1. 客户端向服务端发送 FIN 包, 请求关闭连接, 自己从 Established 状态, 进入 FIN-WAIT-1状态.  这是第一次挥手
2. 服务端收到 FIN包之后, 发送 ACK, 自己进入CLOSE-WAIT 状态. 这是第二次挥手
3. 等服务端把最后的数据发送完毕后, 发送 FIN 包, 进入 LAST-ACK 状态. 这是第三次挥手
4. 客户端接受到 ACK 之后, 进入 FIN-WAIT-2 状态, 等到服务端发送完数据, 接收到服务端发送的来的 FIN 包之后, 进入 FIN-WAIT-2状态, 并回复 ACK 包, 进入超时等待状态. 经过一段超时等待时间后才关闭连接. 这是第四次挥手
5. 服务端收到客户端发来的 ACK 包之后, 理解关闭连接
为什么客户端会有一个超时等待连接, 这是因为如果最后客户端第四次挥手发送的 ACK 包因为线路故障没有到达服务端, 服务端在一段时间后, 可以重传第三次挥手的 FIN 包, 这样客户端可以再做一次第四次挥手. 已确保在不可靠的信道上, 完成可靠的断开连接的操作. ZX

### TCP头部
最小20 个字节
端口号的取值范围 1-65535 = 2^16
源端口大于 1023, 随机产生. 目标端口是协议规定的

|          Source Port       |        Destination Port            |
|                                 Sequence number                      |
|                            Acknowledgement number             |
| Header Length  |  Reserved | Control bits| Window |
|           Checksum         |             Urgent                        |
|                                        Options                                  |
|                                      Data                                          |
* 三次握手中的 ACK, SYN 位都在 Control Bits 的 6 位中

### UDP头部
最小 6或者8 个字节, 因为 CheckSum是可选的
|          Source Port       |        Destination Port           |
|          Length                |            Checksum (可选)     |
|                              Data   (if any)                                 |

# UDP
UDP只是把数据通过网卡发出去, 所以性能损耗少, CPU 等资源占用率低. 但是不能保证丢包. 
UDP 一般用于实时数据, 视频, 语言,  单播, 组播, 广播
其实在带宽好的情况下, UDP 不但不收影响, 传输快, 掉包也不多
TCP 一定是单播的, 组播和广播都不会是 TCP


### TCP 和 UDP 这两种协议的区别
1. 可靠性
	TCP 是面向连接的, 可靠性要求高, 要么不收, 要收就要收完整的. UDP 是面向于无连接的可靠性低
2. 传输速度上, 因为 UDP 不需要三次握手, 传输速度比较快, 延迟小

TCP 的可靠性如何实现
1. 校验和
2. 有确认应答和序列号
3. 有超时重传
4. 连接管理
5. 流量控制
6. 拥塞控制

TCP 头部有哪些标识参与 TCP 三次握手
1. SYN
2. ACK
3. FIN

TCP 和 UDP的实际应用场景
TCP适用于对网络通信质量要求较高的场景, 需要准确无误的发送给对方
1. 传输文件, 邮件, 浏览网页
UDP适用于对实时通信要求高, 但是对少量丢包并没有太大要求的场景
1. 域名查询
2. 语音通话, 视频直播等
3. 隧道网络, 比如 vpn, vxlan


# IP与TCP的关系
在IP包头中 protocol字段会指定上一层传输层的协议。 如果是6 表示上一层是TCP。
同理在二层帧中也有type字段指定网络层的协议， 如果是0x80则说明上一层使用IPv4协议