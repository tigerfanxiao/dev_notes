
RSTP对STP改进

在STP中, 我们是被动的等待. 而在RSTP中是主动的通知. 
会发送P置位的BPDU

### P/A机制
P代表proposal, 提议自己成为对方的指定端口
A代表Aggrement, 同意自己变成根端口

1. RSTP利用P/A机制取消了等待时间. 快速选择DP/RP, 并进入转发状态
2. 为了避免P/A机制的环路问题, 在发送A置位BPDU之前, 将其他接口阻塞, 保证无环
3. 本段收敛完成后, 继续从阻塞端口发送P置位BPDU, 完成下一段P/A协商. 
4. 直到某一段链路上, P置位BPDU没有回复

把stp中的阻塞端口, 区分为AP替代端口, 和BP备份端口
替代端口: 如果我的链路中根端口故障了, 可以立刻把替代端口变为根端口, 而不需要选举. 我阻塞是因为, 别人发给我的BPDU更好, 但是我不是设备上收到BPDU最好的接口
备份端口(不重要): 如果设备自己有两个接口互联了, 或者被插上同一个hub. 此时同一台设备上的两个接口比较. BPDU更差的端口为备份端口. 当自己的指定端口故障的时候, 会激活备份端口

端口状态在RSTP中做了精简
1. Forwarding
2. learning 进行P/A机制. 学习mac地址表
3. Discarding 不学mac地址表

边缘端口EP
管理员可以手动配置连接PC的端口为边缘端口
1. EP不需要进过learning阶段, 直接进入转发状态
2. EP端口如果收到了BPDU, 说明对端不是普通主机, 而是有STP功能的设备. 此时这个端口会重新变成普通端口, 进行RSTP选举
3. 当进行P/A机制时, EP端口不会被丢弃. 丢弃的端口可以是根端口或者指定端口
4. 当收到TC时, EP端口的mac也不会被清空
5. EP端口依旧会发送BPDU

```shell
# 制定单个端口为EP
interface g0/0/4
stp edged-port enable


# 制定所有端口默认是EP
stp edged-port default

# 检查这个端口是否为EP
dis stp interface g0/0/0
```